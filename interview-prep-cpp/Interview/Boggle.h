#include "Interview.h"
/*
using namespace std;

typedef pair<int, int> Point2D;

struct BoardNode
{
public:
	BoardNode(Point2D location, char letter) : m_location(location), m_letter(letter), m_fVisited(false) { }

	bool m_fVisited;
	const Point2D m_location;
	const char m_letter;
	list<BoardNode*> m_neighbors;
};

class Board
{
public:
	Board(string str, int N) : m_N(N), m_nodes(N*N, nullptr)
	{
		assert(str.size() == N * N);
		for (int c = 0; c < N; ++c)
		{
			for (int r = 0; r < N; ++r)
			{
				Point2D location(r, c);
				BoardNode* node = new BoardNode(location, str[ToIndex(location)]);
				m_nodes[ToIndex(location)] = node;
			}
		}


	}
	char GetLetter(int r, int c);

private:
	int ToIndex(const Point2D& location)
	{
		return m_N * location.first + location.second;
	}

	void Connect(BoardNode* n1, BoardNode* n2)
	{
		assert(nullptr != n1);
		assert(nullptr != n2);
		assert(n1->m_neighbors.find(n2) == n1->m_neighbors.end());
		assert(n2->m_neighbors.find(n1) == n2->m_neighbors.end());
		n1->m_neighbors.push_back(n2);
		n2->m_neighbors.push_back(n1);
	}

	const int m_N;
	vector<BoardNode*> m_nodes;
};

class Dictionary
{
public:
	bool IsValidWord(string str) const
	{
		return (m_dict.find(str) != m_dict.end());
	}

	bool IsValidStartOfWord(string str) const
	{
		// TODO: P

	}

private:
	hash_set<string> m_dict;
};

class GameState
{
public:
	GameState(Board* pBoard) : m_pBoard(pBoard), m_fVisited(m_pBoard->GetN()*m_pBoard->GetN(), false)
	{
	}

	bool HasVisited(int r, int c) { return m_fVisited[r * m_pBoard->GetN() + c]; }

	void Visit(int r, int c)
	{
		m_r = r;
		m_c = c;
		m_fVisited[r * m_pBoard->GetN() + c] = true;
		m_word.push_back(m_pBoard->GetLetter(r, c));
	}

	bool IsValidTransition(int r, int c) const
	{
		// Perform bounds checking
		//
		if (r < 0 || r >= m_pBoard->GetN() || c < 0 || c >= m_pBoard->GetN())
		{
			return false;
		}

		// Check if the board letter has already been visited
		//
		if (m_fVisited[r * m_pBoard->GetN() + c])
		{
			return false;
		}

		// Perform English language word check
		//
		char c = m_pBoard->GetLetter(r, c);
		string newWord = m_word;
		newWord.push_back(c);

	}

private:
	void SetVisited(int r, int c) { m_fVisited[r * m_pBoard->GetN() + c] = true; }
	Board* m_pBoard;
	vector<bool> m_fVisited; // where the algorithm has visited
	string m_word; // the current word generated by the visitation path
	int m_r; // the current location
	int m_c; // the current location
};

class Board
{
public:
	Board(string& board)
	{
		assert(board.size() == N*N);
		for (int r = 0; r < N; ++r)
		{
			for (int c = 0; c < N; ++c)
			{
				SetLetter(r, c, board[N]);
			}
		}
	}

	void GetDefaultExplorationState(int r, int c)
	{

	}

	char GetLetter(int r, int c)
	{
		return m_board[r][c];
	}

	int GetN() { return N; }

private:
	void SetLetter(int r, int c, char letter)
	{
		m_board[r][c] = letter;
	}
	char m_board[N][N];
};



class BoggleSolver
{
	static list<string> FindAllWords(Board& b)
	{
		list<string> words;
		// for all starting points on the board, find all words that can be generated from that starting point
		for (int r = 0; r < b.GetN(); ++r)
		{
			for (int c = 0; c < b.GetN(); ++c)
			{
				string word;
				vector<bool> fVisited;
			}
		}
	}

private:
	static list<string> FindAllWords(Board& b, int r, int c, vector<bool>& fVisited, string& word, list<string>& words)
	{
		// given the board and a given current location, and path to that location
		// explore all valid
	}
};
*/